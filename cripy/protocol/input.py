# -*- coding: utf-8 -*-
"""This is an auto-generated file. Modify at your own risk"""
from typing import Awaitable, List, Optional, Union, TYPE_CHECKING

import attr

if TYPE_CHECKING:
    from cripy.types import ConnectionType, SessionType

__all__ = ["Input"]


@attr.dataclass(slots=True)
class Input(object):
    client: Union["ConnectionType", "SessionType"] = attr.ib()

    def dispatchKeyEvent(
        self,
        type: str,
        modifiers: Optional[int] = None,
        timestamp: Optional[float] = None,
        text: Optional[str] = None,
        unmodifiedText: Optional[str] = None,
        keyIdentifier: Optional[str] = None,
        code: Optional[str] = None,
        key: Optional[str] = None,
        windowsVirtualKeyCode: Optional[int] = None,
        nativeVirtualKeyCode: Optional[int] = None,
        autoRepeat: Optional[bool] = None,
        isKeypad: Optional[bool] = None,
        isSystemKey: Optional[bool] = None,
        location: Optional[int] = None,
    ) -> Awaitable[Optional[dict]]:
        """
        Dispatches a key event to the page.

        :param type: Type of the key event.
        :type type: str
        :param modifiers: Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
        :type modifiers: Optional[int]
        :param timestamp: Time at which the event occurred.
        :type timestamp: Optional[float]
        :param text: Text as generated by processing a virtual key code with a keyboard layout. Not needed for for `keyUp` and `rawKeyDown` events (default: "")
        :type text: Optional[str]
        :param unmodifiedText: Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
        :type unmodifiedText: Optional[str]
        :param keyIdentifier: Unique key identifier (e.g., 'U+0041') (default: "").
        :type keyIdentifier: Optional[str]
        :param code: Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
        :type code: Optional[str]
        :param key: Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
        :type key: Optional[str]
        :param windowsVirtualKeyCode: Windows virtual key code (default: 0).
        :type windowsVirtualKeyCode: Optional[int]
        :param nativeVirtualKeyCode: Native virtual key code (default: 0).
        :type nativeVirtualKeyCode: Optional[int]
        :param autoRepeat: Whether the event was generated from auto repeat (default: false).
        :type autoRepeat: Optional[bool]
        :param isKeypad: Whether the event was generated from the keypad (default: false).
        :type isKeypad: Optional[bool]
        :param isSystemKey: Whether the event was a system key event (default: false).
        :type isSystemKey: Optional[bool]
        :param location: Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default: 0).
        :type location: Optional[int]
        """
        msg_dict = dict()
        if type is not None:
            msg_dict["type"] = type
        if modifiers is not None:
            msg_dict["modifiers"] = modifiers
        if timestamp is not None:
            msg_dict["timestamp"] = timestamp
        if text is not None:
            msg_dict["text"] = text
        if unmodifiedText is not None:
            msg_dict["unmodifiedText"] = unmodifiedText
        if keyIdentifier is not None:
            msg_dict["keyIdentifier"] = keyIdentifier
        if code is not None:
            msg_dict["code"] = code
        if key is not None:
            msg_dict["key"] = key
        if windowsVirtualKeyCode is not None:
            msg_dict["windowsVirtualKeyCode"] = windowsVirtualKeyCode
        if nativeVirtualKeyCode is not None:
            msg_dict["nativeVirtualKeyCode"] = nativeVirtualKeyCode
        if autoRepeat is not None:
            msg_dict["autoRepeat"] = autoRepeat
        if isKeypad is not None:
            msg_dict["isKeypad"] = isKeypad
        if isSystemKey is not None:
            msg_dict["isSystemKey"] = isSystemKey
        if location is not None:
            msg_dict["location"] = location
        return self.client.send("Input.dispatchKeyEvent", msg_dict)

    def insertText(self, text: str) -> Awaitable[Optional[dict]]:
        """
        This method emulates inserting text that doesn't come from a key press,
for example an emoji keyboard or an IME.

        :param text: The text to insert.
        :type text: str
        """
        msg_dict = dict()
        if text is not None:
            msg_dict["text"] = text
        return self.client.send("Input.insertText", msg_dict)

    def dispatchMouseEvent(
        self,
        type: str,
        x: float,
        y: float,
        modifiers: Optional[int] = None,
        timestamp: Optional[float] = None,
        button: Optional[str] = None,
        clickCount: Optional[int] = None,
        deltaX: Optional[float] = None,
        deltaY: Optional[float] = None,
    ) -> Awaitable[Optional[dict]]:
        """
        Dispatches a mouse event to the page.

        :param type: Type of the mouse event.
        :type type: str
        :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
        :type x: float
        :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        :type y: float
        :param modifiers: Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
        :type modifiers: Optional[int]
        :param timestamp: Time at which the event occurred.
        :type timestamp: Optional[float]
        :param button: Mouse button (default: "none").
        :type button: Optional[str]
        :param clickCount: Number of times the mouse button was clicked (default: 0).
        :type clickCount: Optional[int]
        :param deltaX: X delta in CSS pixels for mouse wheel event (default: 0).
        :type deltaX: Optional[float]
        :param deltaY: Y delta in CSS pixels for mouse wheel event (default: 0).
        :type deltaY: Optional[float]
        """
        msg_dict = dict()
        if type is not None:
            msg_dict["type"] = type
        if x is not None:
            msg_dict["x"] = x
        if y is not None:
            msg_dict["y"] = y
        if modifiers is not None:
            msg_dict["modifiers"] = modifiers
        if timestamp is not None:
            msg_dict["timestamp"] = timestamp
        if button is not None:
            msg_dict["button"] = button
        if clickCount is not None:
            msg_dict["clickCount"] = clickCount
        if deltaX is not None:
            msg_dict["deltaX"] = deltaX
        if deltaY is not None:
            msg_dict["deltaY"] = deltaY
        return self.client.send("Input.dispatchMouseEvent", msg_dict)

    def dispatchTouchEvent(
        self,
        type: str,
        touchPoints: List[dict],
        modifiers: Optional[int] = None,
        timestamp: Optional[float] = None,
    ) -> Awaitable[Optional[dict]]:
        """
        Dispatches a touch event to the page.

        :param type: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while TouchStart and TouchMove must contains at least one.
        :type type: str
        :param touchPoints: Active touch points on the touch device. One event per any changed point (compared to previous touch event in a sequence) is generated, emulating pressing/moving/releasing points one by one.
        :type touchPoints: List[dict]
        :param modifiers: Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
        :type modifiers: Optional[int]
        :param timestamp: Time at which the event occurred.
        :type timestamp: Optional[float]
        """
        msg_dict = dict()
        if type is not None:
            msg_dict["type"] = type
        if touchPoints is not None:
            msg_dict["touchPoints"] = touchPoints
        if modifiers is not None:
            msg_dict["modifiers"] = modifiers
        if timestamp is not None:
            msg_dict["timestamp"] = timestamp
        return self.client.send("Input.dispatchTouchEvent", msg_dict)

    def emulateTouchFromMouseEvent(
        self,
        type: str,
        x: int,
        y: int,
        button: str,
        timestamp: Optional[float] = None,
        deltaX: Optional[float] = None,
        deltaY: Optional[float] = None,
        modifiers: Optional[int] = None,
        clickCount: Optional[int] = None,
    ) -> Awaitable[Optional[dict]]:
        """
        Emulates touch event from the mouse event parameters.

        :param type: Type of the mouse event.
        :type type: str
        :param x: X coordinate of the mouse pointer in DIP.
        :type x: int
        :param y: Y coordinate of the mouse pointer in DIP.
        :type y: int
        :param button: Mouse button.
        :type button: str
        :param timestamp: Time at which the event occurred (default: current time).
        :type timestamp: Optional[float]
        :param deltaX: X delta in DIP for mouse wheel event (default: 0).
        :type deltaX: Optional[float]
        :param deltaY: Y delta in DIP for mouse wheel event (default: 0).
        :type deltaY: Optional[float]
        :param modifiers: Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
        :type modifiers: Optional[int]
        :param clickCount: Number of times the mouse button was clicked (default: 0).
        :type clickCount: Optional[int]
        """
        msg_dict = dict()
        if type is not None:
            msg_dict["type"] = type
        if x is not None:
            msg_dict["x"] = x
        if y is not None:
            msg_dict["y"] = y
        if button is not None:
            msg_dict["button"] = button
        if timestamp is not None:
            msg_dict["timestamp"] = timestamp
        if deltaX is not None:
            msg_dict["deltaX"] = deltaX
        if deltaY is not None:
            msg_dict["deltaY"] = deltaY
        if modifiers is not None:
            msg_dict["modifiers"] = modifiers
        if clickCount is not None:
            msg_dict["clickCount"] = clickCount
        return self.client.send("Input.emulateTouchFromMouseEvent", msg_dict)

    def setIgnoreInputEvents(self, ignore: bool) -> Awaitable[Optional[dict]]:
        """
        Ignores input events (useful while auditing page).

        :param ignore: Ignores input events processing when set to true.
        :type ignore: bool
        """
        msg_dict = dict()
        if ignore is not None:
            msg_dict["ignore"] = ignore
        return self.client.send("Input.setIgnoreInputEvents", msg_dict)

    def synthesizePinchGesture(
        self,
        x: float,
        y: float,
        scaleFactor: float,
        relativeSpeed: Optional[int] = None,
        gestureSourceType: Optional[str] = None,
    ) -> Awaitable[Optional[dict]]:
        """
        Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

        :param x: X coordinate of the start of the gesture in CSS pixels.
        :type x: float
        :param y: Y coordinate of the start of the gesture in CSS pixels.
        :type y: float
        :param scaleFactor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
        :type scaleFactor: float
        :param relativeSpeed: Relative pointer speed in pixels per second (default: 800).
        :type relativeSpeed: Optional[int]
        :param gestureSourceType: Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
        :type gestureSourceType: Optional[str]
        """
        msg_dict = dict()
        if x is not None:
            msg_dict["x"] = x
        if y is not None:
            msg_dict["y"] = y
        if scaleFactor is not None:
            msg_dict["scaleFactor"] = scaleFactor
        if relativeSpeed is not None:
            msg_dict["relativeSpeed"] = relativeSpeed
        if gestureSourceType is not None:
            msg_dict["gestureSourceType"] = gestureSourceType
        return self.client.send("Input.synthesizePinchGesture", msg_dict)

    def synthesizeScrollGesture(
        self,
        x: float,
        y: float,
        xDistance: Optional[float] = None,
        yDistance: Optional[float] = None,
        xOverscroll: Optional[float] = None,
        yOverscroll: Optional[float] = None,
        preventFling: Optional[bool] = None,
        speed: Optional[int] = None,
        gestureSourceType: Optional[str] = None,
        repeatCount: Optional[int] = None,
        repeatDelayMs: Optional[int] = None,
        interactionMarkerName: Optional[str] = None,
    ) -> Awaitable[Optional[dict]]:
        """
        Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

        :param x: X coordinate of the start of the gesture in CSS pixels.
        :type x: float
        :param y: Y coordinate of the start of the gesture in CSS pixels.
        :type y: float
        :param xDistance: The distance to scroll along the X axis (positive to scroll left).
        :type xDistance: Optional[float]
        :param yDistance: The distance to scroll along the Y axis (positive to scroll up).
        :type yDistance: Optional[float]
        :param xOverscroll: The number of additional pixels to scroll back along the X axis, in addition to the given distance.
        :type xOverscroll: Optional[float]
        :param yOverscroll: The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
        :type yOverscroll: Optional[float]
        :param preventFling: Prevent fling (default: true).
        :type preventFling: Optional[bool]
        :param speed: Swipe speed in pixels per second (default: 800).
        :type speed: Optional[int]
        :param gestureSourceType: Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
        :type gestureSourceType: Optional[str]
        :param repeatCount: The number of times to repeat the gesture (default: 0).
        :type repeatCount: Optional[int]
        :param repeatDelayMs: The number of milliseconds delay between each repeat. (default: 250).
        :type repeatDelayMs: Optional[int]
        :param interactionMarkerName: The name of the interaction markers to generate, if not empty (default: "").
        :type interactionMarkerName: Optional[str]
        """
        msg_dict = dict()
        if x is not None:
            msg_dict["x"] = x
        if y is not None:
            msg_dict["y"] = y
        if xDistance is not None:
            msg_dict["xDistance"] = xDistance
        if yDistance is not None:
            msg_dict["yDistance"] = yDistance
        if xOverscroll is not None:
            msg_dict["xOverscroll"] = xOverscroll
        if yOverscroll is not None:
            msg_dict["yOverscroll"] = yOverscroll
        if preventFling is not None:
            msg_dict["preventFling"] = preventFling
        if speed is not None:
            msg_dict["speed"] = speed
        if gestureSourceType is not None:
            msg_dict["gestureSourceType"] = gestureSourceType
        if repeatCount is not None:
            msg_dict["repeatCount"] = repeatCount
        if repeatDelayMs is not None:
            msg_dict["repeatDelayMs"] = repeatDelayMs
        if interactionMarkerName is not None:
            msg_dict["interactionMarkerName"] = interactionMarkerName
        return self.client.send("Input.synthesizeScrollGesture", msg_dict)

    def synthesizeTapGesture(
        self,
        x: float,
        y: float,
        duration: Optional[int] = None,
        tapCount: Optional[int] = None,
        gestureSourceType: Optional[str] = None,
    ) -> Awaitable[Optional[dict]]:
        """
        Synthesizes a tap gesture over a time period by issuing appropriate touch events.

        :param x: X coordinate of the start of the gesture in CSS pixels.
        :type x: float
        :param y: Y coordinate of the start of the gesture in CSS pixels.
        :type y: float
        :param duration: Duration between touchdown and touchup events in ms (default: 50).
        :type duration: Optional[int]
        :param tapCount: Number of times to perform the tap (e.g. 2 for double tap, default: 1).
        :type tapCount: Optional[int]
        :param gestureSourceType: Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
        :type gestureSourceType: Optional[str]
        """
        msg_dict = dict()
        if x is not None:
            msg_dict["x"] = x
        if y is not None:
            msg_dict["y"] = y
        if duration is not None:
            msg_dict["duration"] = duration
        if tapCount is not None:
            msg_dict["tapCount"] = tapCount
        if gestureSourceType is not None:
            msg_dict["gestureSourceType"] = gestureSourceType
        return self.client.send("Input.synthesizeTapGesture", msg_dict)
