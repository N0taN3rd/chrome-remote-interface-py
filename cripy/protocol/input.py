"""This is an auto-generated file. Modify at your own risk"""
from typing import Awaitable, Any, Dict, List, Optional, Union, TYPE_CHECKING

if TYPE_CHECKING:
    from cripy import ConnectionType, SessionType

__all__ = ["Input"]


class Input:
    """
    See `https://chromedevtools.github.io/devtools-protocol/tot/Input`
    """

    __slots__ = ["client"]

    def __init__(self, client: Union["ConnectionType", "SessionType"]) -> None:
        """Initialize a new instance of Input

        :param client: The client instance to be used to communicate with the remote browser instance
        """
        self.client: Union["ConnectionType", "SessionType"] = client

    def dispatchKeyEvent(
        self,
        type: str,
        modifiers: Optional[int] = None,
        timestamp: Optional[Union[int, float]] = None,
        text: Optional[str] = None,
        unmodifiedText: Optional[str] = None,
        keyIdentifier: Optional[str] = None,
        code: Optional[str] = None,
        key: Optional[str] = None,
        windowsVirtualKeyCode: Optional[int] = None,
        nativeVirtualKeyCode: Optional[int] = None,
        autoRepeat: Optional[bool] = None,
        isKeypad: Optional[bool] = None,
        isSystemKey: Optional[bool] = None,
        location: Optional[int] = None,
    ) -> Awaitable[Dict]:
        """
        Dispatches a key event to the page.

        See `https://chromedevtools.github.io/devtools-protocol/tot/Input#method-dispatchKeyEvent`

        :param type: Type of the key event.
        :param modifiers: Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
         (default: 0).
        :param timestamp: Time at which the event occurred.
        :param text: Text as generated by processing a virtual key code with a keyboard layout. Not needed for
         for `keyUp` and `rawKeyDown` events (default: "")
        :param unmodifiedText: Text that would have been generated by the keyboard if no modifiers were pressed (except for
         shift). Useful for shortcut (accelerator) key handling (default: "").
        :param keyIdentifier: Unique key identifier (e.g., 'U+0041') (default: "").
        :param code: Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
        :param key: Unique DOM defined string value describing the meaning of the key in the context of active
         modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
        :param windowsVirtualKeyCode: Windows virtual key code (default: 0).
        :param nativeVirtualKeyCode: Native virtual key code (default: 0).
        :param autoRepeat: Whether the event was generated from auto repeat (default: false).
        :param isKeypad: Whether the event was generated from the keypad (default: false).
        :param isSystemKey: Whether the event was a system key event (default: false).
        :param location: Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
         0).
        :return: The results of the command
        """
        msg = {"type": type}
        if modifiers is not None:
            msg["modifiers"] = modifiers
        if timestamp is not None:
            msg["timestamp"] = timestamp
        if text is not None:
            msg["text"] = text
        if unmodifiedText is not None:
            msg["unmodifiedText"] = unmodifiedText
        if keyIdentifier is not None:
            msg["keyIdentifier"] = keyIdentifier
        if code is not None:
            msg["code"] = code
        if key is not None:
            msg["key"] = key
        if windowsVirtualKeyCode is not None:
            msg["windowsVirtualKeyCode"] = windowsVirtualKeyCode
        if nativeVirtualKeyCode is not None:
            msg["nativeVirtualKeyCode"] = nativeVirtualKeyCode
        if autoRepeat is not None:
            msg["autoRepeat"] = autoRepeat
        if isKeypad is not None:
            msg["isKeypad"] = isKeypad
        if isSystemKey is not None:
            msg["isSystemKey"] = isSystemKey
        if location is not None:
            msg["location"] = location
        return self.client.send("Input.dispatchKeyEvent", msg)

    def insertText(self, text: str) -> Awaitable[Dict]:
        """
        This method emulates inserting text that doesn't come from a key press,
        for example an emoji keyboard or an IME.

        Status: Experimental

        See `https://chromedevtools.github.io/devtools-protocol/tot/Input#method-insertText`

        :param text: The text to insert.
        :return: The results of the command
        """
        return self.client.send("Input.insertText", {"text": text})

    def dispatchMouseEvent(
        self,
        type: str,
        x: Union[int, float],
        y: Union[int, float],
        modifiers: Optional[int] = None,
        timestamp: Optional[Union[int, float]] = None,
        button: Optional[str] = None,
        buttons: Optional[int] = None,
        clickCount: Optional[int] = None,
        deltaX: Optional[Union[int, float]] = None,
        deltaY: Optional[Union[int, float]] = None,
        pointerType: Optional[str] = None,
    ) -> Awaitable[Dict]:
        """
        Dispatches a mouse event to the page.

        See `https://chromedevtools.github.io/devtools-protocol/tot/Input#method-dispatchMouseEvent`

        :param type: Type of the mouse event.
        :param x: X coordinate of the event relative to the main frame's viewport in CSS pixels.
        :param y: Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
         the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
        :param modifiers: Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
         (default: 0).
        :param timestamp: Time at which the event occurred.
        :param button: Mouse button (default: "none").
        :param buttons: A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
         Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
        :param clickCount: Number of times the mouse button was clicked (default: 0).
        :param deltaX: X delta in CSS pixels for mouse wheel event (default: 0).
        :param deltaY: Y delta in CSS pixels for mouse wheel event (default: 0).
        :param pointerType: Pointer type (default: "mouse").
        :return: The results of the command
        """
        msg = {"type": type, "x": x, "y": y}
        if modifiers is not None:
            msg["modifiers"] = modifiers
        if timestamp is not None:
            msg["timestamp"] = timestamp
        if button is not None:
            msg["button"] = button
        if buttons is not None:
            msg["buttons"] = buttons
        if clickCount is not None:
            msg["clickCount"] = clickCount
        if deltaX is not None:
            msg["deltaX"] = deltaX
        if deltaY is not None:
            msg["deltaY"] = deltaY
        if pointerType is not None:
            msg["pointerType"] = pointerType
        return self.client.send("Input.dispatchMouseEvent", msg)

    def dispatchTouchEvent(
        self,
        type: str,
        touchPoints: List[Dict[str, Any]],
        modifiers: Optional[int] = None,
        timestamp: Optional[Union[int, float]] = None,
    ) -> Awaitable[Dict]:
        """
        Dispatches a touch event to the page.

        See `https://chromedevtools.github.io/devtools-protocol/tot/Input#method-dispatchTouchEvent`

        :param type: Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
         TouchStart and TouchMove must contains at least one.
        :param touchPoints: Active touch points on the touch device. One event per any changed point (compared to
         previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
         one by one.
        :param modifiers: Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
         (default: 0).
        :param timestamp: Time at which the event occurred.
        :return: The results of the command
        """
        msg = {"type": type, "touchPoints": touchPoints}
        if modifiers is not None:
            msg["modifiers"] = modifiers
        if timestamp is not None:
            msg["timestamp"] = timestamp
        return self.client.send("Input.dispatchTouchEvent", msg)

    def emulateTouchFromMouseEvent(
        self,
        type: str,
        x: int,
        y: int,
        button: str,
        timestamp: Optional[Union[int, float]] = None,
        deltaX: Optional[Union[int, float]] = None,
        deltaY: Optional[Union[int, float]] = None,
        modifiers: Optional[int] = None,
        clickCount: Optional[int] = None,
    ) -> Awaitable[Dict]:
        """
        Emulates touch event from the mouse event parameters.

        Status: Experimental

        See `https://chromedevtools.github.io/devtools-protocol/tot/Input#method-emulateTouchFromMouseEvent`

        :param type: Type of the mouse event.
        :param x: X coordinate of the mouse pointer in DIP.
        :param y: Y coordinate of the mouse pointer in DIP.
        :param button: Mouse button.
        :param timestamp: Time at which the event occurred (default: current time).
        :param deltaX: X delta in DIP for mouse wheel event (default: 0).
        :param deltaY: Y delta in DIP for mouse wheel event (default: 0).
        :param modifiers: Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
         (default: 0).
        :param clickCount: Number of times the mouse button was clicked (default: 0).
        :return: The results of the command
        """
        msg = {"type": type, "x": x, "y": y, "button": button}
        if timestamp is not None:
            msg["timestamp"] = timestamp
        if deltaX is not None:
            msg["deltaX"] = deltaX
        if deltaY is not None:
            msg["deltaY"] = deltaY
        if modifiers is not None:
            msg["modifiers"] = modifiers
        if clickCount is not None:
            msg["clickCount"] = clickCount
        return self.client.send("Input.emulateTouchFromMouseEvent", msg)

    def setIgnoreInputEvents(self, ignore: bool) -> Awaitable[Dict]:
        """
        Ignores input events (useful while auditing page).

        See `https://chromedevtools.github.io/devtools-protocol/tot/Input#method-setIgnoreInputEvents`

        :param ignore: Ignores input events processing when set to true.
        :return: The results of the command
        """
        return self.client.send("Input.setIgnoreInputEvents", {"ignore": ignore})

    def synthesizePinchGesture(
        self,
        x: Union[int, float],
        y: Union[int, float],
        scaleFactor: Union[int, float],
        relativeSpeed: Optional[int] = None,
        gestureSourceType: Optional[str] = None,
    ) -> Awaitable[Dict]:
        """
        Synthesizes a pinch gesture over a time period by issuing appropriate touch events.

        Status: Experimental

        See `https://chromedevtools.github.io/devtools-protocol/tot/Input#method-synthesizePinchGesture`

        :param x: X coordinate of the start of the gesture in CSS pixels.
        :param y: Y coordinate of the start of the gesture in CSS pixels.
        :param scaleFactor: Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
        :param relativeSpeed: Relative pointer speed in pixels per second (default: 800).
        :param gestureSourceType: Which type of input events to be generated (default: 'default', which queries the platform
         for the preferred input type).
        :return: The results of the command
        """
        msg = {"x": x, "y": y, "scaleFactor": scaleFactor}
        if relativeSpeed is not None:
            msg["relativeSpeed"] = relativeSpeed
        if gestureSourceType is not None:
            msg["gestureSourceType"] = gestureSourceType
        return self.client.send("Input.synthesizePinchGesture", msg)

    def synthesizeScrollGesture(
        self,
        x: Union[int, float],
        y: Union[int, float],
        xDistance: Optional[Union[int, float]] = None,
        yDistance: Optional[Union[int, float]] = None,
        xOverscroll: Optional[Union[int, float]] = None,
        yOverscroll: Optional[Union[int, float]] = None,
        preventFling: Optional[bool] = None,
        speed: Optional[int] = None,
        gestureSourceType: Optional[str] = None,
        repeatCount: Optional[int] = None,
        repeatDelayMs: Optional[int] = None,
        interactionMarkerName: Optional[str] = None,
    ) -> Awaitable[Dict]:
        """
        Synthesizes a scroll gesture over a time period by issuing appropriate touch events.

        Status: Experimental

        See `https://chromedevtools.github.io/devtools-protocol/tot/Input#method-synthesizeScrollGesture`

        :param x: X coordinate of the start of the gesture in CSS pixels.
        :param y: Y coordinate of the start of the gesture in CSS pixels.
        :param xDistance: The distance to scroll along the X axis (positive to scroll left).
        :param yDistance: The distance to scroll along the Y axis (positive to scroll up).
        :param xOverscroll: The number of additional pixels to scroll back along the X axis, in addition to the given
         distance.
        :param yOverscroll: The number of additional pixels to scroll back along the Y axis, in addition to the given
         distance.
        :param preventFling: Prevent fling (default: true).
        :param speed: Swipe speed in pixels per second (default: 800).
        :param gestureSourceType: Which type of input events to be generated (default: 'default', which queries the platform
         for the preferred input type).
        :param repeatCount: The number of times to repeat the gesture (default: 0).
        :param repeatDelayMs: The number of milliseconds delay between each repeat. (default: 250).
        :param interactionMarkerName: The name of the interaction markers to generate, if not empty (default: "").
        :return: The results of the command
        """
        msg = {"x": x, "y": y}
        if xDistance is not None:
            msg["xDistance"] = xDistance
        if yDistance is not None:
            msg["yDistance"] = yDistance
        if xOverscroll is not None:
            msg["xOverscroll"] = xOverscroll
        if yOverscroll is not None:
            msg["yOverscroll"] = yOverscroll
        if preventFling is not None:
            msg["preventFling"] = preventFling
        if speed is not None:
            msg["speed"] = speed
        if gestureSourceType is not None:
            msg["gestureSourceType"] = gestureSourceType
        if repeatCount is not None:
            msg["repeatCount"] = repeatCount
        if repeatDelayMs is not None:
            msg["repeatDelayMs"] = repeatDelayMs
        if interactionMarkerName is not None:
            msg["interactionMarkerName"] = interactionMarkerName
        return self.client.send("Input.synthesizeScrollGesture", msg)

    def synthesizeTapGesture(
        self,
        x: Union[int, float],
        y: Union[int, float],
        duration: Optional[int] = None,
        tapCount: Optional[int] = None,
        gestureSourceType: Optional[str] = None,
    ) -> Awaitable[Dict]:
        """
        Synthesizes a tap gesture over a time period by issuing appropriate touch events.

        Status: Experimental

        See `https://chromedevtools.github.io/devtools-protocol/tot/Input#method-synthesizeTapGesture`

        :param x: X coordinate of the start of the gesture in CSS pixels.
        :param y: Y coordinate of the start of the gesture in CSS pixels.
        :param duration: Duration between touchdown and touchup events in ms (default: 50).
        :param tapCount: Number of times to perform the tap (e.g. 2 for double tap, default: 1).
        :param gestureSourceType: Which type of input events to be generated (default: 'default', which queries the platform
         for the preferred input type).
        :return: The results of the command
        """
        msg = {"x": x, "y": y}
        if duration is not None:
            msg["duration"] = duration
        if tapCount is not None:
            msg["tapCount"] = tapCount
        if gestureSourceType is not None:
            msg["gestureSourceType"] = gestureSourceType
        return self.client.send("Input.synthesizeTapGesture", msg)
